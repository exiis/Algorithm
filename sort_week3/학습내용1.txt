# 제  목 : 알고리즘 3주차 강의내용
# 작성일 : 2021-03-19
# 작성자 : 손상훈


# 1. 순환(Recursion)
> 재귀를 사용한 알고리즘의 구현.
> 대표적으로 피보나치의 구현 방법이 있다.
> Fn = Fn-1 + Fn-2

## 1-1. 순환에 있어서 무한 반복을 방지하기 위하여 break point가 필요하다.
## 1-2. Recursive solution은 다음을 포함하여야함
	> base case - return값을 주는 해결부분
	> recursive case - 점점 더 작은 매개변수로 함수를 부르는 부분
        > recursive case가 무한반복을 깨는 조건이라고 할 수 있음.

> 순환을 이야기 한 이유?
   * 분할정복의 기초가 되기 때문.


# 2. 분할정복식 설계 전략
> Divide and Conquer 전략
 * 분할, 정복, 통합 세가지 부분으로 나뉘어짐

## 2-1. 분할 : 해결하기 쉽도록 문제를 작은 여러개의 부분으로 나눈다.
## 2-2. 정복 : 나눈 문제를 각각 해결한다.
		> 순환적으로 해결
		> 작은 입력에 대해서는 직접 해결
## 2-3. 통합 : 해결된 작은 문제의 답을 모아서 원래 문제의 해답으로 구성.

 * 큰것부터 작은것으로 내려가는 것에 착안하여 < Top Down > 해결 방법으로 소개함.


# 3. 최대연속부분합
> 입력 : 배열x [] (원소는 n개)
> 출력 : 연속적인 부분의 합 중 최대합

## 3-1. 분할정복으로 해결하자면?
	[ 31 -41 59 26 -53 58 97 -93 -23 84 ]
	> 반으로 나누어 생각한다.

	[ 31 -41 59 26 -53 ] [ 58 97 -93 -23 84 ]
	...
	...
	...
	> 크기가 n/2인 두개의 부분 문제로 나누어 각각을 순환적으로 해결한 후 결합한다.
	> 이와 같은 방법은 logN 번까지 내려간다. (depth가 logN, log의 밑은 2)
	> 작은 문제(좌, 우)에서 구한것과 경계선, 세가지의 경우를 비교하면 답을 찾을 수 있음.
	> O(N logN) : 총 N개의 자료 * logN의 깊이
	

# 4. 퀵정렬(Quicksort)
> 분할교환을 사용한 정렬방법
> 평균적으로 좋은 성능을 가짐
> 작은 스택만 있으면 별도의 메모리를 요구하지 않는다.
> 불안정적인 제자리 알고리즘
> O(NlogN) - 최악의 경우 n^2이나 평균적으로 NlogN을 보장한다.

## 4-1. 분할정복식 설계 전략
	> divide, conquer, combine 활용.
	> divide : key값은 i를 중심으로 좌, 우를 나눈다.
	  * i의 경우 i의 좌측은 모두 i보다 작은 값, 우측은 i보다 큰값으로 나눈다.
	
### 4-1-1. 배열 쪼개기(partition)
	> 배열 a[l:r]에서 a[r]을 pivot으로 선정
	> 피봇을 기준으로 a[]의 원소들을 두개의 partition으로 분할
	 * 왼쪽 오른쪽 화살표 비교하면서 화살표를 당겨옴.
	 * 피봇보다 큰 값, 작은값을 찾을 때 까지 화살표를 당김
	 * 이후 두개의 자리를 바꿈
	 * 왼쪽 오른쪽 화살표가 교차되면 종료
	> 분할 후 피봇은 a[i]로 들어가게됨. (a[i]와 피봇을 교환한다)
	> 왼쪽 partition의 원소는 모두 피봇보다 작다.
	> 오른쪽은 모두 피봇보다 크다.

> Heap sort는 최악의 경우에도 O(NlogN)을 보장하나, 평균적으로 quick sort가 더 빠르다.

## 4-2. Quick Sort의 성능 향상 방법
	> 스택을 사용하여 순환을제거
	 : 반복문을 사용한다.
	> 작은 부분 배열의 경우 삽입정렬 사용
	 : if Left < Right && Right - Left <= M then use Insertion Sort
	   M : 5 ~ 25 내의 범위 정도를 권장
	   많은 응용에서 약 20% 정도의 시간 절감 효과가 있다.
	   재귀 호출 이전에 if문을 사용하여 분기점을 하나 생성.
	> 중간값 분할 (Median-of-Three Partitioning)
	 : l, r, middle 원소 중 값이 중간인 원소를 pivot으로 선택한다.
	   최악의 경우가 발생하는 확률을 낮추어준다.
	   전체 수행시간의 5%정도 절감효과
