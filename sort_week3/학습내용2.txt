/* 2021-03-23 */


# 합병정렬(Merge sort)

## 합병정렬?
> 두개의 정렬된 화일을 하나의 큰 정렬된 화일로 병합함
> 분할 정복
> 두 부분 배열의 크기가 동일하게 분할.
 * 퀵정렬과 다르게 적용되는 부분
> 최악의 경우에도 NlogN에 비례하게된다.

## 분할정복식 설계전략
> DIVIDE - 배열을 반으로 분할
> CONQUER(sort) - 부분 배열을 순환적으로 정렬
> COMBINE(merge) - 두개의 정렬된 작은 배열을 하나의 큰 배열로 합병

## STEP : MERGE
> 1. 반으로 분리된(이미 정렬되어 있어야함) 각각의 배열에 대하여 0번째 원소부터 비교.
> 2. 더 큰쪽을 원래 배열에 집어넣음. 집어넣은 원소는 다음번째를 가리킨다.
> 3. 계속 비교하면서 분리된 배열을 모두 삽입하여 하나의 배열을 만든다.

## 성능 특정
> 최악의 경우 시간 복잡도 O(NlogN)
> 입력 배열에 민감하지 않음
> 안정적
> N에 비례하는 추가 기억장소가 필요하기 때문에 제자리 정렬은 아님

## Non - Recursive Merge Sort
> 하나씩 분리된 상태에서 이웃한 부분들을 합친다.
> Down - Up 방식


# 퀵 vs 합병

## 퀵 : 정복-분할
> 순환 이전에 대부분의 작업 수행
> 불안정적

## 합병: 분할-정복
> 처음 두 부분으로 분할 후 각 부분을 개별적으로 정복
> 안정적


# 행렬 곱셈(Matrix Multiplication)
> n*n 크기의 행렬의 곱?

## 쉬트라쎈의 방법(2*2)
> m1 ~ m7을 구함
> 각 행열의 위치에 해당하는 수식을 계산하여 구한다.

## n*n?
> n은 2의 거듭제곱일 때
> n/2 * n/2 행렬로 분할한다.


# 분할정복을 사용하지 않는 경우
> 크기가 n인 입력이 2개 이상의 조각으로 분할되고, 분할된 부분들의 크기가 거의 n에 가깝게 되는 경우
 * 시간복잡도 : 지수 시간
 ex) [ 1 2 3 4 5 6 7 8 9 ] -> [ 1 2 ] [ 3 4 5 6 7 8 9 ]
> 크기가 n인 입력이 거의 n개의 조각으로 분할되며 분할된 부분의 크기가 n/c인 경우
 ex) [ 1 2 3 4 5 ] -> [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]
