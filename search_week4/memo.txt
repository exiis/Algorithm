#week_4 Search Algorithm

# 1. 순차 탐색(Sequential Search)
 > 순서 없이 저장되어 있는 리스트를 탐색 (배열 or Linked List)
 > 첫 번째 레코드부터 비교를 시작하여 탐색 진행.
 > 새로운 레코드는 배열의 마지막에 삽입
 > 비교횟수 ?
   1. 성공적이지 않은 탐색(리스트에 값이 없는 경우) 항상 N회의 비교가 필요하다.
   2. 성공적인 탐색에 대하여는 평균적으로 N/2회의 비교가 필요하다.
   3. 정렬된 연결 리스트로 구현된 순차 탐색은 성공적/성공적이지 않은 탐색 모두 평균적으로 N/2회의 비교를 진행한다.

## 순차탐색의 성능 향상법?
 > 접근 빈도수를 알 때
  : 빈도수가 가장 높은 레코드를 앞쪽에 배치한다.
    적은 양의 레코드가 집중적으로 접근되면 효율성이 높아짐

 > 접근 빈도수를 모를때
  : 자체-조직(self-organizing) 탐색
    링크드 리스트로 구현하는 것이 적합하다.
    많은 접근이 인접한 레코드에 대하여 이루어지는 경우 효율성이 높아진다.


# 2. 이진 탐색(Binary Search)
 > 분할 정복 방법을 사용한다.
 > 성능의 특성
  : 성공적, 성공적이지 않은 탐색 모두 logN+1회 이상의 비교를 하지 않는다.
    리스트가 정렬되어 있어야 하므로 정렬에 대한 추가적인 비용이 든다.


# 3. 이진 트리 탐색
 > 이진 탐색 트리
  : 작은 키를 가지고 있는 모든 레코드는 왼쪽
    큰 키를 가지고 있는 모든 레코드는 오른쪽에 있다.

 > 탐색 과정
  : 루트와 주어진 키를 비교
    같으면 종료
    키값이 작다면 왼쪽으로
    키값이 크다면 오른쪽으로 이동

 > 트리를 중위 순회 하면 데이터를 정렬하는 것과 같은 효과를 볼 수 있음.

